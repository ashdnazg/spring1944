#define TAK //this is a TAK script

#include "STANDARD_COMMANDS_GPL.h"

piece  torso, flare, pelvis, rthigh, lthigh, lleg, rleg, rfoot, 
		lfoot, luparm, lloarm, ground, gun, ruparm, rloarm, head;
		
/* --Var defs:
-----Boolean
---
bEngaged - is the unit currently aiming at anything? or was it recently aiming at anything (time controlled by restoreafterdelay)
	Controls: timing of idle animations, the usage of AimRunControl over RunControl
	Set by: Aimweapon, unset by X
---
bNading - is the unit currently in the process of throwing a grenade?
	Controls: locks out weaponready, and X
	Set by: fireweapon of the nade script, unset by same at the end
---
bMoving - is the unit currently moving? 
	Controls: various animations.
	Set by: StartMoving, unset by StopMoving
---
-----Integer
---
iState - what the unit is currently doing //todo: add states for being in a transport, update killed and aimweapon accordingly
	Controls: which aiming anim to use, among others.
	 Set by: everything that changes the state of the unit. *Control, HitbyWeapon, RestoreFromCrawl, ect
	  Values:
		standing idle - 0
		standing at attention - 1
		standing aiming rifle - 2
		standing aiming nade - 3
		-		
		running - 4
		running aiming - 5
		-
		prone 'idle' - 6
		prone aiming - 7
		crawling - 8
		-
		pinned - 9 
---
iFear - how 'afraid' unit currently is. 
	Controls: if unit is crawling/prone or standing.
	Controls: pinned status.
	 Set by: increased by HitbyWeapon on impact of suitable weapon, decreased by FearRecovery
	  Values: 0-16
	  iFear = 0-14 = prone/crawling
	  iFear > 14 = pinned, unable to fire or crawl.
---
	
*/

static-var bEngaged, bNading, bMoving, iState, iFear;


//signals to handle control of..everything
#define SIG_RUN 2
#define SIG_AIMRUN 4
#define SIG_CRAWL 8
#define SIG_AIM1 16
#define SIG_AIM2 32
#define SIG_PINNEDCTRL 64
#define SIG_FEARRECOVERY 128
#define SIG_RESTOREFROMCRAWL 256


//unit definitions
#define USE_RIFLE_STANCE1	1
#define WEAPON_GRENADE
#define FLAGKILLER
#define GUN_QUERY_PIECENUM	flare
#define IdleDelay	10000

//FX definitions
	//random placeholders for stuff (blood? I don't know what else inf would need. maybe they should piss and smoke while idle...)
#define placeholder_EFFECT01 1024+1
#define placeholder_EFFECT02 1024+2
#define placeholder_EFFECT03 1024+3
#define placeholder_EFFECT04 1024+4
#define placeholder_EFFECT05 1024+5
#define placeholder_EFFECT06 1024+6
	//muzzle flash
#define RIFLE_MUZZLEFLASH 1024+7
//#include "includes/infantry.h"
#include "inf_suppressionvars.h"
#include "infposes.h"
WeaponReady() //structure is here to allow for multiple poses (either per unit class or even multiples per unit class)
{
bEngaged = FALSE;
#ifdef WEAPON_GRENADE
	if (!bNading)
	{
	#ifdef USE_RIFLE_STANCE1
	RIFLE_STANCE1
	#endif
	//#ifdef USE_RIFLE_STANCE2
	//RIFLE_STANCE2
	//#endif
	#ifdef USE_SMG_STANCE1
	SMG_STANCE1
	#endif
	}

//#ifdef USE_PTRD_STANCE
#endif
}

StartMoving()
{
	bMoving = 1;
}

StopMoving()
{
	bMoving = 0;
}

/*Idle animations.
Todo: add animations <_<, keep signal mask list up to date, remove to an #include for neatness.
 
Also perhaps specify them by unit/unit class using a define, since 'schreck troops do different
things with their weapons while idle than a SMGer or something
*/
Idle1()
{
set-signal-mask SIG_RUN;
set-signal-mask SIG_AIMRUN;
set-signal-mask SIG_CRAWL;
set-signal-mask SIG_AIM1;


}

Idle2()
{
set-signal-mask SIG_RUN;
set-signal-mask SIG_AIMRUN;
set-signal-mask SIG_CRAWL;
set-signal-mask SIG_AIM1;

}

Idle3()
{
set-signal-mask SIG_RUN;
set-signal-mask SIG_AIMRUN;
set-signal-mask SIG_CRAWL;
set-signal-mask SIG_AIM1;

}

AimRun() //running animation while aiming at a target.
//TODO: slow them down? and make a different anim
{
	var mult;
	mult = (3/4);
	var Desync;
	Desync = rand(20,50);
		turn torso to x-axis <7> now;
		if (bMoving==1)
			{
			turn rleg to x-axis <50> speed<540>*mult;	
			turn rthigh to x-axis <-40> speed<270>*mult;
			turn lthigh to x-axis <30> speed<270>*mult;
			//turn torso to y-axis <10> speed <90>*mult;	
		wait-for-move pelvis along y-axis;		
			move pelvis to y-axis [0.1] speed <2800>;
		wait-for-move pelvis along y-axis;
			turn rleg to x-axis <10> speed <630>*mult;
			move pelvis to y-axis [0] speed <2800>;
			}		
		if (bMoving==1)
			{
			turn lleg to x-axis <50> speed<540>*mult;
			turn lthigh to x-axis <-40> speed<270>*mult;
			turn rthigh to x-axis <30> speed <270>*mult;
		//	turn torso to y-axis <-10> speed <90>;
		wait-for-move pelvis along y-axis;
			move pelvis to y-axis [0.1] speed <2800>;	
		wait-for-move pelvis along y-axis;
			turn lleg to x-axis <10> speed <630>*mult;
			move pelvis to y-axis [0] speed <2800>;
			}
		sleep Desync;
}

Run() //basic jog when there is no fear or aiming
{
	var Desync;
	Desync = rand(20,50);
		turn torso to x-axis <7> now;
		if (bMoving==1)
			{
			turn rleg to x-axis <85> speed<540>;	
			turn rthigh to x-axis <-60> speed<270>;
			turn lthigh to x-axis <30> speed<270>;
			turn torso to y-axis <10> speed <90>;	
		wait-for-move pelvis along y-axis;		
			move pelvis to y-axis [0.4] speed <2800>;
		wait-for-move pelvis along y-axis;
			turn rleg to x-axis <10> speed <630>;
			move pelvis to y-axis [0] speed <2800>;
			}		
		if (bMoving==1)
			{
			turn lleg to x-axis <85> speed<540>;
			turn lthigh to x-axis <-60> speed<270>;
			turn rthigh to x-axis <30> speed <270>;
			turn torso to y-axis <-10> speed <90>;
		wait-for-move pelvis along y-axis;
			move pelvis to y-axis [0.4] speed <2800>;	
		wait-for-move pelvis along y-axis;
			turn lleg to x-axis <10> speed <630>;
			move pelvis to y-axis [0] speed <2800>;
			}
		sleep Desync;
}

Crawl() //crawl under fire (moving, iFear>0, but not pinned)
//todo - actually write the anim
{
	var Desync;
	Desync = rand(20,50);
		turn torso to x-axis <7> now;
		if (bMoving==1)
			{
			turn rleg to x-axis <85> speed<540>;	
			turn rthigh to x-axis <-60> speed<270>;
			turn lthigh to x-axis <30> speed<270>;
			turn torso to y-axis <10> speed <90>;	
		wait-for-move pelvis along y-axis;		
			move pelvis to y-axis [0.4] speed <2800>;
		wait-for-move pelvis along y-axis;
			turn rleg to x-axis <10> speed <630>;
			move pelvis to y-axis [0] speed <2800>;
			}		
		if (bMoving==1)
			{
			turn lleg to x-axis <85> speed<540>;
			turn lthigh to x-axis <-60> speed<270>;
			turn rthigh to x-axis <30> speed <270>;
			turn torso to y-axis <-10> speed <90>;
		wait-for-move pelvis along y-axis;
			move pelvis to y-axis [0.4] speed <2800>;	
		wait-for-move pelvis along y-axis;
			turn lleg to x-axis <10> speed <630>;
			move pelvis to y-axis [0] speed <2800>;
			}
		sleep Desync;
}

Stand() //just resetting legs and such while still
{
move pelvis to y-axis [0.0] now;
turn pelvis to x-axis <0> now;
turn pelvis to y-axis <0> now;
turn torso to x-axis <0> now;
wait-for-turn rthigh around x-axis;
turn rthigh to x-axis <0> now;
wait-for-turn lthigh around x-axis;
turn lthigh to x-axis <0> now;
turn lleg to x-axis <0> now;
turn rleg to x-axis <0> now;
}		


//state loops, with what kills them

/* 
--Standard run state & idle anims (not aiming, no fear, not crawling)--

Killed by:
AimRunControl
CrawlControl
FearRecovery
setSFXOccupy
Death
*/

RunControl() 
{
signal SIG_AIMRUN;
set-signal-mask SIG_RUN;
var pickIdleAnim;
	while(1)
	{
	  if (bMoving == 1)
	  {
		iState=4; //just running
	  	call-script Run(); //this has a sleep at the end of it, so theoretically no lockups
	  	start-script WeaponReady();
	  }
	  
	  if (bMoving == 0)
	  {
	  	iState=1; //standing at attention
		call-script Stand();
		if (!bEngaged)
		{
		sleep IdleDelay;
		iState=0; //standing idle
		//idlestuff; TODO - add anims & picking mechanism
		}
		sleep 200;
	  }
	}
}

/* 
--Aiming run state & idle anims (aiming, no fear, not crawling)--

Killed by:
RunControl
CrawlControl
FearRecovery
setSFXOccupy
Death
*/

AimRunControl()
{
signal SIG_RUN;
set-signal-mask SIG_AIMRUN;
var pickIdleAnim;
	while(1)
	{
	  if (!bMoving)
	  {
	  	iState=2;
		call-script Stand();
		if (!bEngaged)
		{
		iState=1;
		//idlestuff; TODO - add anims & picking mechanism
		}
		sleep 200;
	  }
	  iState=5; //running and aiming
      if (bMoving) call-script AimRun();
	}
}


/* 
--Crawling state & idle anims (not aiming/aiming, fear, not pinned)--

Killed by:
RestoreFromCrawl
PinnedControl
setSFXOccupy
Death
*/

CrawlControl()
{
signal SIG_RUN;
signal SIG_AIMRUN;
set-signal-mask SIG_CRAWL;
var pickIdleAnim;
	while(1)
	{
	  if (!bMoving)
	  {
	  	iState=7; //prone & aiming
		if (!bEngaged)
		{
		iState=6;
		//idlestuff; TODO - add anims & picking mechanism
		}
		sleep 200;
	  }
	  iState=8; //crawling
      if (bMoving) call-script Crawl();
	}
}

/*
--Fear handling & behavior --
*/

RestoreFromPinned()
{
	iState=0;
}

PinnedControl() //hit the dirt and kiss your ass goodbye...
{
signal SIG_PINNEDCTRL;
set-signal-mask SIG_PINNEDCTRL;
	if (iFear>PinnedLevel)
	{
	signal SIG_CRAWL;
	iState=9;
	//anim - either in here or in a separate script
	sleep 100;
	}
}

TakeCover()
{
SET MAX_SPEED to [0.00001];
SET ARMORED to TRUE;
	if (iState < 6)
	{
	iState=6;
	SET UPRIGHT to 0;
	}
sleep 100;
return(0);
}

RestoreAfterCover() //get up out of the dirt. also controls going into pinned mode.
{
	
	if (iFear > PinnedLevel)
	{
	call-script PinnedControl();
	sleep 100;
	} 
	if (iFear <=0 && iState==6 || iFear <= 0 && iState==7 || iFear <=0 && iState==8)
	{	
	signal SIG_CRAWL;
	signal SIG_PINNEDCTRL;
	set MAX_SPEED to [0.0];
	//insert anim, with wait-for-turns to make sure it finishes
	iFear=0; //in the off chance that it was negative.
	iState=1;
	SET UPRIGHT TO 1;
	SET ARMORED to FALSE;
	set MAX_SPEED to [0.5];
	call-script RunControl();
	}
return (1);
sleep 100;
}

FearRecovery() 
{ 
	signal SIG_AIMRUN;
	signal SIG_RUN;
	signal SIG_FEARRECOVERY;
	set-signal-mask SIG_FEARRECOVERY;

	if (iFear>PinnedLevel && iState==9) call-script PinnedControl();
	
     while(iFear > 0) 
        { 
			if (iFear>0 && iFear < PinnedLevel && iState==9)
			{
			call-script RestoreFromPinned();
			sleep 100;
			}
        iFear = iFear - RecoverConstant; 
        sleep RecoverRate; 
        } 
start-script RestoreAfterCover();   
return (1); 
}


HitByWeaponId(z,x,id,damage)
{	
	if (Id<=300 || Id>700) return 100;
	
	if (300<Id && Id<=400) //301-400=small arms or very small calibre cannon: MGs, snipers, LMGs, 20mm
		iFear = iFear + LittleFear;
	if (400<Id && Id<=500) //401-500=small/med explosions: mortars, 75mm guns and under
		iFear = iFear + MedFear;
	if (500<Id && Id<=600) //501-600=large explosions: small bombs, 155mm - 88mm guns,
		iFear = iFear + BigFear;
	if (600<Id && Id<=700) //601-700=omgwtfbbq explosions: medium/large bombs, 170+mm guns, rocket arty 
		iFear = iFear + MortalFear;

	if (iFear > FearLimit) iFear = FearLimit; // put this line AFTER increasing fear var
		
	start-script TakeCover();
	sleep 500; // guys stay down for at least this long, no matter what (even if they recover from the fear instantly)
	start-script FearRecovery();
	
	return (0); 
}
//lets Lua suppression notification see what fear is at
luaFunction(arg1)
{
 arg1 = iFear;
}

//transport state handling


setSFXoccupy(level)
{
return 0; //awaiting info on what states and such will actually be needed
}

Create()
{
	hide GUN_QUERY_PIECENUM; //thanks to gnome for this inspired idea. no more stupid showing flares...
	bMoving = 0;
	bEngaged = 0;
	bNading = 0;
	iState = 1;
	iFear = 0;
	
	call-script WeaponReady();
	start-script RunControl();
}

RestoreAfterDelay()
{
//sleep RestoreDelay;
if (iFear>0) call-script CrawlControl();
if (iFear <=0) call-script RunControl();
//blah blah blah
}

//start weapons

AimFromWeapon1(piecenum)
{
	piecenum = head;
}

QueryWeapon1(piecenum)
{
	piecenum = flare;
}

/*
Primary weapon. 
States: crawling/prone, running.
Killed by:
Grenade aiming
PinnedControl

*/

AimWeapon1(heading, pitch)
{
	signal SIG_AIM1;
	set-signal-mask SIG_AIM1;
	bEngaged=1; 
	signal SIG_RUN;
	if (iState == 9) return 0; //if the unit is pinned, we don't even bother aiming or calling the control loop	
	start-script AimRunControl();

	if (iState>=6)
	{
		iState=7; //prone aiming
		//animation la de da
		start-script RestoreAfterDelay();
		return (1);
	}
	
	if (iState<6)
	{	
	
		if (bMoving==1)
		{
			iState=5; //moving animing			
			//animation la de da	
			return (1);
		} 
	
		if (bMoving==0)
		{
			iState=2; //standing aiming rifle
			//animation la de da			
			return (1);
		} 
	}
	
	return (0);
}

FireWeapon1()
{
	
	if (iState>=6)
	{
		return (1);
	}
	if (iState<6)
	{
		return (1);
	}
	
	return (0);

}

Killed(severity, corpsetype)
{
signal SIG_RUN;
signal SIG_AIMRUN;
signal SIG_CRAWL;
signal SIG_AIM1;
signal SIG_AIM2; //however many AIMs there are
signal SIG_PINNEDCTRL;
signal SIG_FEARRECOVERY;
signal SIG_RESTOREFROMCRAWL;

//Bullet/fragment kills
	if (severity <=50)
	{
		if (iState>=6)
			{
			//death anims suitable for a soldier who is prone on the ground
			//	wait-for-turn blah blah;
			//corpsetype = blah blah;
			return (1);
			}
		
		if (iState<6)
			{
			//death anims suitable for a standing/soldier - these can be broken up still further based on
			// more added states or however many death anims we make. I suppose the running ones should be separate from standing death anims.
			
			//	wait-for-turn blah blah;
			//corpsetype = blah blah;
			return (1);
			}
	}
	
	if (severity > 50)
	{
		//At first I thought this was overkill, but now I realize that having the per-state death anim for big hits means
		// we can more accurately (the right pieces, in the right direction) emit effects/move pieces, should we choose to make things gory.
		if (iState>=6)
			{
			//death anims suitable for a soldier who is prone on the ground
			//	wait-for-turn blah blah;
			//corpsetype = blah blah;
			return (1);
			}
		
		if (iState<6)
			{
			//death anims suitable for a standing/soldier - these can be broken up still further based on
			// more added states or however many death anims we make. I suppose the running ones should be separate from standing death anims.
			//	wait-for-turn blah blah;
			//corpsetype = blah blah;
			return (1);
			}
	}
}